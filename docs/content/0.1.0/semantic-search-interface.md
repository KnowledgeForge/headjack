---
date: 0000-01-01
categories: ["docs"]
weight: 3
title: The Semantic Search Interface
date: 0000-01-01
draft: false
authors: ["Headjack Devs"]
description: ""
featuredImage: ""
tags: ["how-to"]
series: ["getting-started"]
series_weight: 3
lightgallery: true
---

Headjack facilitates using a collection of embeddings to enable semantic features but does not facilitate creating the embeddings themselves. There
are many great solutions out there to generate the embeddings, including some vector databases that include built-in embedding solutions. Here are just
a few of the options to consider.

- A
- B
- C

# The Semantic Search Interface

The Semantic Search Interface is a very simple abstract base class that can be used to create semantic search integrations for any type of datastore.

```py
class SemanticSearch(abc):
    ...
    @abc.method
    def query_dj(self. query: str) -> List[str]:
        """"
        Query DataJunction nodes
        """
        ...
    
    @abc.method
    def query_knowledge(self, query: str) -> List[str]:
        """
        Query knowledge documents
        """
        ...
    
    @abc.method
    def ping(self) -> bool:
        """
        Ping the datastore
        """
        ...
```

Custom semantic search implementations all derive from the `SemanticSearch` base class. To learn how to create a custom implementation,
it's helpful to look at an existing one such as `ChromaSemanticSearch`.

```py
class ChromaSemanticSearch(SemanticSearch):
    """
    A headjack semantic search implementation for use with a Chroma database
    """
    
    def __init__(self, client):
        self.client = client

    @abc.method
    def query_dj(self. query: str) -> List[str]:
        """"
        Query Chroma, filtered to document_type='datajunction'
        """
        self.client.query("...", metadata={"type": "datajunction"})
        return results
    
    @abc.method
    def query_knowledge(self, query: str) -> List[str]:
        """
        Query Chroma, filtered to document_type='knowledge'
        """
        results = self.client.query("...", metadata={"type": "knowledge"})
        return results
    
    @abc.method
    def ping(self) -> bool:
        """
        Ping the Chroma database
        """
        self.client.health()
        return results
```

# How Semantic Search Implementations Are Used

When a semantic question or command is sent to Headjack, it performas a semantic search to find the most closely related information.

- DataJunction nodes
- Passages from knowledge documents
- Organization segments, i.e. Finance, Product, Engineering
- and more...

Once headjack has filtered the potentially vast amounts of embedded data down to those pieces of information that are most relevant to
the question or command, it utilizes that information through an assortment of LangChain tools. These tools then leverage available
large language models such as `A` or `B` to determine specific scoped actions. These scoped actions are what power Headjacks core features.

- Summarizing DataJunction metrics and dimensions with rich business descriptions
- Executing requests to DataJunction to calculate metrics and group them by a set of dimensions
- Create visualizations of metrics data generated by DataJunction
- Simultaneous exploration of business knowledge as well as metric definitions
- Suggest new DataJunction metric definitions
- Suggest descriptions for existing DataJunction metric definitions

Semantic search is a critical component for quickly narrowing large swaths of available information to allow the language model to only
operate on a small subset of closely related and contextually relevant information.
